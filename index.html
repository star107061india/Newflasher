<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pi Bot Professional - Final Edition</title>
  <style>
    :root { --background: #212121; --surface: #313131; --primary: #00e676; --text: #f5f5f5; --error: #ff5252; --success: #69f0ae; --info: #40c4ff; --border: #424242; }
    body { font-family: 'Segoe UI', sans-serif; background-color: var(--background); color: var(--text); margin: 0; padding: 20px; font-size: 14px; }
    .container { max-width: 1000px; margin: auto; background-color: var(--surface); border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.5); overflow: hidden; display: flex; }
    .config-panel { width: 65%; padding: 25px; border-right: 1px solid var(--border); }
    .log-panel { width: 35%; padding: 25px; display: flex; flex-direction: column; background-color: #2a2a2a; }
    h1, h2 { color: var(--primary); text-shadow: 0 0 8px rgba(0, 230, 118, 0.4); border-bottom: 1px solid var(--border); padding-bottom: 10px; margin-top: 0; }
    h2 { font-size: 16px; margin-top: 25px; }
    .form-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    .form-group.full-width { grid-column: 1 / -1; }
    label { display: block; margin-bottom: 8px; font-weight: 600; color: #e0e0e0; }
    small { color: #bdbdbd; display: block; margin-top: 5px; font-size: 11px; font-style: italic; }
    input, select { width: 100%; background-color: #212121; border: 1px solid #555; border-radius: 5px; padding: 10px; color: var(--text); box-sizing: border-box; transition: border-color 0.2s; }
    input:focus, select:focus { border-color: var(--primary); outline: none; }
    button { padding: 12px; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; transition: all 0.2s; font-size: 14px; }
    #startButton { background-color: var(--primary); color: #111; }
    #stopButton { background-color: #757575; color: #f5f5f5; }
    .log-box { flex-grow: 1; background-color: #212121; border-radius: 5px; padding: 12px; font-family: 'Fira Code', 'Courier New', monospace; font-size: 12px; overflow-y: auto; margin-top: 10px; border: 1px solid var(--border); }
    .log-entry { margin-bottom: 8px; } .log-time { color: #9e9e9e; } .log-success { color: #69f0ae; } .log-error { color: #ff5252; } .log-info { color: #40c4ff; }
    .status-display { text-align: center; padding: 15px; background-color: #212121; border-radius: 5px; margin-bottom: 15px; font-weight: bold; border: 1px solid var(--border); }
    .status-waiting { color: #e0e0e0; } .status-attacking { color: var(--primary); } .status-success { color: var(--success); } .status-failed { color: var(--error); }
  </style>
</head>
<body>
  <div class="container">
    <div class="config-panel">
      <h1>Pi Bot Professional - Final Edition</h1>

      <h2>Account Configuration</h2>
      <div class="form-grid">
        <div class="form-group full-width">
          <label>Your Secret Keyphrase (Sender)</label>
          <input type="password" id="mnemonicInput">
        </div>
        <div class="form-group full-width">
          <label>Sponsor's Secret Keyphrase (Fee Payer)</label>
          <input type="password" id="sponsorMnemonicInput">
          <small>Leave blank to pay fees from the sender's account.</small>
        </div>
        <div class="form-group full-width">
          <label>Locked Balances</label>
          <div style="display:flex; gap:10px;">
            <select id="claimableIdSelect" style="flex-grow:1;"></select>
            <button id="fetchBalancesButton" style="background-color:#4a4a4a;color:#fff;">Fetch</button>
          </div>
        </div>
        <div class="form-group full-width">
          <label>Receiver Pi Address</label>
          <input type="text" id="receiverAddressInput">
        </div>
      </div>

      <h2>Attack Parameters</h2>
      <div class="form-grid">
        <div class="form-group">
          <label>Unlock Time (Local)</label>
          <input type="text" id="unlockTimeInput" placeholder="YYYY-MM-DDTHH:MM:SS">
        </div>
        <div class="form-group">
          <label>Early Call Time (ms)</label>
          <input type="number" id="earlyCallTimeInput" value="0">
        </div>
        <div class="form-group">
          <label>Scanning Frequency (ms)</label>
          <input type="number" id="scanFrequencyInput" value="500">
        </div>
        <div class="form-group">
          <label>Time Limit (seconds)</label>
          <input type="number" id="timeLimitInput" value="20">
        </div>
        <div class="form-group">
          <label>Records Per Attempt</label>
          <input type="number" id="recordsPerAttemptInput" value="1">
        </div>
        <div class="form-group">
          <label>Fee Multiplier</label>
          <input type="number" id="feeMultiplierInput" value="2">
        </div>
        <div class="form-group">
          <label>Auto Retry Interval (ms)</label>
          <input type="number" id="retryIntervalInput" value="0">
          <small>0 = retry disabled</small>
        </div>
      </div>
    </div>

    <div class="log-panel">
      <h2>Attack Log & Status</h2>
      <div id="statusDisplay" class="status-display status-waiting">STATUS: WAITING</div>
      <div id="logBox" class="log-box">Initialize your settings and start the attack.</div>
      <div class="form-grid" style="margin-top: 20px;">
        <button id="startButton">Start Attack</button>
        <button id="stopButton" disabled>Stop Attack</button>
      </div>
    </div>
  </div>

<script>
  const el = {
    mnemonic: document.getElementById('mnemonicInput'),
    sponsorMnemonic: document.getElementById('sponsorMnemonicInput'),
    claimableId: document.getElementById('claimableIdSelect'),
    fetchBalances: document.getElementById('fetchBalancesButton'),
    receiver: document.getElementById('receiverAddressInput'),
    unlockTime: document.getElementById('unlockTimeInput'),
    earlyCall: document.getElementById('earlyCallTimeInput'),
    scanFrequency: document.getElementById('scanFrequencyInput'),
    timeLimit: document.getElementById('timeLimitInput'),
    recordsPerAttempt: document.getElementById('recordsPerAttemptInput'),
    feeMultiplier: document.getElementById('feeMultiplierInput'),
    retryInterval: document.getElementById('retryIntervalInput'),
    start: document.getElementById('startButton'),
    stop: document.getElementById('stopButton'),
    status: document.getElementById('statusDisplay'),
    logBox: document.getElementById('logBox'),
  };

  let botInterval = null, lockedBalancesCache = [];

  function log(type, message) {
    const time = new Date().toLocaleTimeString();
    el.logBox.innerHTML += `<div class="log-entry"><span class="log-time">[${time}]</span> <span class="log-${type}">${message}</span></div>`;
    el.logBox.scrollTop = el.logBox.scrollHeight;
  }

  function updateStatus(statusType, message) {
    el.status.className = `status-display status-${statusType}`;
    el.status.textContent = `STATUS: ${message}`;
  }

  async function fetchBalances() {
    log('info', 'Fetching balances...');
    el.fetchBalances.disabled = true;
    updateStatus('waiting', 'FETCHING...');
    try {
      const res = await fetch('/.netlify/functions/getClaimableBalances', {
        method: 'POST', body: JSON.stringify({
          mnemonic: el.mnemonic.value,
          sponsorMnemonic: el.sponsorMnemonic.value
        })
      });
      const result = await res.json();
      if (!result.success) throw new Error(result.error);

      lockedBalancesCache = result.balances;
      el.claimableId.innerHTML = '';
      if (lockedBalancesCache.length === 0) log('info', 'No locked balances found.');
      else {
        lockedBalancesCache.forEach(b => el.claimableId.add(new Option(`Amount: ${b.amount} Pi`, b.id)));
        log('success', `Found ${lockedBalancesCache.length} balance(s).`);
      }
      log('info', `Fee Payer Balance: ${result.feePayerBalance} Pi`);
      updateStatus('waiting', 'READY');
    } catch (err) { log('error', `Fetch failed: ${err.message}`); updateStatus('failed', 'FETCH FAILED'); }
    finally { el.fetchBalances.disabled = false; }
  }

  async function attemptTransaction() {
    log('info', 'Attempting transaction...');
    try {
      const res = await fetch('/.netlify/functions/submitTransaction', {
        method: 'POST',
        body: JSON.stringify({
          senderMnemonic: el.mnemonic.value,
          sponsorMnemonic: el.sponsorMnemonic.value,
          claimableId: el.claimableId.value,
          receiverAddress: el.receiver.value,
          unlockTime: el.unlockTime.value,
          feeMultiplier: el.feeMultiplier.value,
          recordsPerAttempt: el.recordsPerAttempt.value,
          amount: lockedBalancesCache.find(b => b.id === el.claimableId.value)?.amount || '0'
        })
      });
      const result = await res.json();
      if (!result.success) {
        log('error', `Attempt failed: ${result.error}`);
        return false;
      } else {
        log('success', `✅✅✅ TRANSACTION SUCCESSFUL! Hash: ${result.hash}`);
        return true;
      }
    } catch (err) {
      log('error', `Critical error: ${err.message}. Backend might have crashed.`);
      return false;
    }
  }

  function startBot() {
    if (botInterval) return;
    if (!el.mnemonic.value || !el.unlockTime.value || !el.claimableId.value) {
      log('error', 'Keyphrase, Unlock Time, and a selected Balance are required.');
      return;
    }

    el.start.disabled = true; el.stop.disabled = false;
    updateStatus('waiting', 'INITIALIZING...');

    const unlockTime = new Date(el.unlockTime.value).getTime(); // Local parsing
    const earlyCall = parseInt(el.earlyCall.value, 10);
    const scanFreq = parseInt(el.scanFrequency.value, 10);
    const timeLimit = parseInt(el.timeLimit.value, 10) * 1000;
    const retryInterval = parseInt(el.retryInterval.value, 10);

    const startTime = unlockTime - earlyCall;
    const waitTime = startTime - Date.now();

    log('info', `Attack will begin at ${new Date(startTime).toLocaleTimeString()} (${earlyCall}ms early).`);
    if (waitTime > 0) log('info', `Waiting for ${Math.round(waitTime / 1000)}s...`);

    setTimeout(() => {
      updateStatus('attacking', 'ATTACKING NOW!');
      const endTime = Date.now() + timeLimit;
      botInterval = setInterval(async () => {
        if (Date.now() > endTime) {
          log('error', 'Time limit reached. Bot stopped.');
          stopBot(); return;
        }
        const success = await attemptTransaction();
        if (success) {
          updateStatus('success', 'SUCCESS!');
          stopBot();
        } else if (retryInterval > 0) {
          log('info', `Retrying in ${retryInterval} ms...`);
          await new Promise(res => setTimeout(res, retryInterval));
        }
      }, scanFreq);
    }, waitTime > 0 ? waitTime : 0);
  }

  function stopBot() {
    if (botInterval) { clearInterval(botInterval); botInterval = null; }
    el.start.disabled = false; el.stop.disabled = true;
    if(el.status.textContent !== 'STATUS: SUCCESS!') updateStatus('failed', 'STOPPED');
    log('info', 'Bot has been stopped.');
  }

  el.fetchBalances.addEventListener('click', fetchBalances);
  el.start.addEventListener('click', startBot);
  el.stop.addEventListener('click', stopBot);
</script>
</body>
</html>
