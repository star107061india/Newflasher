<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pi Bot Professional - Final Edition</title>
  <style>
    :root { --background: #212121; --surface: #313131; --primary: #00e676; --text: #f5f5f5; --error: #ff5252; --success: #69f0ae; --info: #40c4ff; --border: #424242; }
    body { font-family: 'Segoe UI', sans-serif; background-color: var(--background); color: var(--text); margin: 0; padding: 20px; font-size: 14px; }
    .container { max-width: 1000px; margin: auto; background-color: var(--surface); border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.5); overflow: hidden; display: flex; }
    .config-panel { width: 65%; padding: 25px; border-right: 1px solid var(--border); }
    .log-panel { width: 35%; padding: 25px; display: flex; flex-direction: column; background-color: #2a2a2a; }
    h1, h2 { color: var(--primary); text-shadow: 0 0 8px rgba(0, 230, 118, 0.4); border-bottom: 1px solid var(--border); padding-bottom: 10px; margin-top: 0; }
    h2 { font-size: 16px; margin-top: 25px; }
    .form-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    .form-group.full-width { grid-column: 1 / -1; }
    label { display: block; margin-bottom: 8px; font-weight: 600; color: #e0e0e0; }
    small { color: #bdbdbd; display: block; margin-top: 5px; font-size: 11px; font-style: italic; }
    input, select { width: 100%; background-color: #212121; border: 1px solid #555; border-radius: 5px; padding: 10px; color: var(--text); box-sizing: border-box; transition: border-color 0.2s; }
    input:focus, select:focus { border-color: var(--primary); outline: none; }
    button { padding: 12px; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; transition: all 0.2s; font-size: 14px; }
    #startButton { background-color: var(--primary); color: #111; }
    #stopButton { background-color: #757575; color: #f5f5f5; }
    .log-box { flex-grow: 1; background-color: #212121; border-radius: 5px; padding: 12px; font-family: 'Fira Code', 'Courier New', monospace; font-size: 12px; overflow-y: auto; margin-top: 10px; border: 1px solid var(--border); }
    .log-entry { margin-bottom: 8px; } .log-time { color: #9e9e9e; } .log-success { color: #69f0ae; } .log-error { color: #ff5252; } .log-info { color: #40c4ff; }
    .status-display { text-align: center; padding: 15px; background-color: #212121; border-radius: 5px; margin-bottom: 15px; font-weight: bold; border: 1px solid var(--border); }
    .status-waiting { color: #e0e0e0; } .status-attacking { color: var(--primary); } .status-success { color: var(--success); } .status-failed { color: var(--error); }
  </style>
</head>
<body>
  <div class="container">
    <div class="config-panel">
      <h1>Pi Bot Professional - Final Edition</h1>

      <h2>Account Configuration</h2>
      <div class="form-grid">
        <div class="form-group full-width">
          <label>Your Secret Keyphrase (Sender)</label>
          <input type="password" id="mnemonicInput">
        </div>
        <div class="form-group full-width">
          <label>Sponsor's Secret Keyphrase (Fee Payer)</label>
          <input type="password" id="sponsorMnemonicInput">
          <small>Leave blank to pay fees from the sender's account.</small>
        </div>
        <div class="form-group full-width">
          <label>Locked Balances</label>
          <div style="display:flex; gap:10px;">
            <select id="claimableIdSelect" style="flex-grow:1;"></select>
            <button id="fetchBalancesButton" style="background-color:#4a4a4a;color:#fff;">Fetch</button>
          </div>
        </div>
        <div class="form-group full-width">
          <label>Receiver Pi Address</label>
          <input type="text" id="receiverAddressInput">
        </div>
      </div>

      <h2>Attack Parameters</h2>
      <div class="form-grid">
        <!-- Renamed: this is now Start Time (Local) used only to start the bot -->
        <div class="form-group">
          <label>Start Time (Local)</label>
          <input type="text" id="unlockTimeInput" placeholder="YYYY-MM-DDTHH:MM:SS">
          <small>Local machine time. This only starts the bot; it will NOT force-submit a transaction at this instant.</small>
        </div>

        <div class="form-group">
          <label>Early Call Time (ms)</label>
          <input type="number" id="earlyCallTimeInput" value="0">
        </div>

        <div class="form-group">
          <label>Scanning Frequency (ms)</label>
          <input type="number" id="scanFrequencyInput" value="500">
        </div>

        <div class="form-group">
          <label>Time Limit (seconds)</label>
          <input type="number" id="timeLimitInput" value="20">
        </div>

        <div class="form-group">
          <label>Records Per Attempt</label>
          <input type="number" id="recordsPerAttemptInput" value="1">
        </div>

        <div class="form-group">
          <label>Fee Multiplier</label>
          <input type="number" id="feeMultiplierInput" value="2">
        </div>

        <div class="form-group">
          <label>Auto Retry Interval (ms)</label>
          <input type="number" id="retryIntervalInput" value="500">
          <small>Time between retry attempts. 0 = disabled.</small>
        </div>

        <div class="form-group">
          <label>Max Retry Attempts</label>
          <input type="number" id="maxRetryAttemptsInput" value="5">
          <small>Number of sequential retries after a failed attempt (0 = no retries).</small>
        </div>
      </div>
    </div>

    <div class="log-panel">
      <h2>Attack Log & Status</h2>
      <div id="statusDisplay" class="status-display status-waiting">STATUS: WAITING</div>
      <div id="logBox" class="log-box">Initialize your settings and start the attack.</div>
      <div class="form-grid" style="margin-top: 20px;">
        <button id="startButton">Start Attack</button>
        <button id="stopButton" disabled>Stop Attack</button>
      </div>
    </div>
  </div>

<script>
  const el = {
    mnemonic: document.getElementById('mnemonicInput'),
    sponsorMnemonic: document.getElementById('sponsorMnemonicInput'),
    claimableId: document.getElementById('claimableIdSelect'),
    fetchBalances: document.getElementById('fetchBalancesButton'),
    receiver: document.getElementById('receiverAddressInput'),
    unlockTime: document.getElementById('unlockTimeInput'), // now Start Time (Local)
    earlyCall: document.getElementById('earlyCallTimeInput'),
    scanFrequency: document.getElementById('scanFrequencyInput'),
    timeLimit: document.getElementById('timeLimitInput'),
    recordsPerAttempt: document.getElementById('recordsPerAttemptInput'),
    feeMultiplier: document.getElementById('feeMultiplierInput'),
    retryInterval: document.getElementById('retryIntervalInput'),
    maxRetryAttempts: document.getElementById('maxRetryAttemptsInput'),
    start: document.getElementById('startButton'),
    stop: document.getElementById('stopButton'),
    status: document.getElementById('statusDisplay'),
    logBox: document.getElementById('logBox'),
  };

  let botInterval = null, lockedBalancesCache = [], isBusy = false, startTimeout = null;

  function log(type, message) {
    const time = new Date().toLocaleTimeString();
    el.logBox.innerHTML += `<div class="log-entry"><span class="log-time">[${time}]</span> <span class="log-${type}">${message}</span></div>`;
    el.logBox.scrollTop = el.logBox.scrollHeight;
  }

  function updateStatus(statusType, message) {
    el.status.className = `status-display status-${statusType}`;
    el.status.textContent = `STATUS: ${message}`;
  }

  async function fetchBalances() {
    log('info', 'Fetching balances...');
    el.fetchBalances.disabled = true;
    updateStatus('waiting', 'FETCHING...');
    try {
      const res = await fetch('/.netlify/functions/getClaimableBalances', {
        method: 'POST', body: JSON.stringify({
          mnemonic: el.mnemonic.value,
          sponsorMnemonic: el.sponsorMnemonic.value
        })
      });
      const result = await res.json();
      if (!result.success) throw new Error(result.error);

      lockedBalancesCache = result.balances || [];
      el.claimableId.innerHTML = '';
      if (!lockedBalancesCache.length) log('info', 'No locked balances found.');
      else {
        lockedBalancesCache.forEach(b => el.claimableId.add(new Option(`Amount: ${b.amount} Pi`, b.id)));
        log('success', `Found ${lockedBalancesCache.length} balance(s).`);
      }
      if (result.feePayerBalance !== undefined) log('info', `Fee Payer Balance: ${result.feePayerBalance} Pi`);
      updateStatus('waiting', 'READY');
    } catch (err) { 
      log('error', `Fetch failed: ${err.message}`); 
      updateStatus('failed', 'FETCH FAILED');
    } finally { el.fetchBalances.disabled = false; }
  }

  async function attemptTransaction() {
    log('info', 'Attempting transaction...');
    try {
      const res = await fetch('/.netlify/functions/submitTransaction', {
        method: 'POST',
        body: JSON.stringify({
          senderMnemonic: el.mnemonic.value,
          sponsorMnemonic: el.sponsorMnemonic.value,
          claimableId: el.claimableId.value,
          receiverAddress: el.receiver.value,
          // NOTE: start time input is used only to start the bot — we don't force submit at that instant
          feeMultiplier: el.feeMultiplier.value,
          recordsPerAttempt: el.recordsPerAttempt.value,
          amount: (lockedBalancesCache.find(b => b.id === el.claimableId.value)?.amount || '0')
        })
      });
      const result = await res.json();
      if (!result.success) {
        log('error', `Attempt failed: ${result.error}`);
        return false;
      } else {
        log('success', `✅✅✅ TRANSACTION SUCCESSFUL! Hash: ${result.hash || result.response?.hash || 'N/A'}`);
        return true;
      }
    } catch (err) {
      log('error', `Critical error: ${err.message}. Backend might have crashed.`);
      return false;
    }
  }

  // small sleep helper
  const sleep = ms => new Promise(res => setTimeout(res, ms));

  function startBot() {
    if (botInterval || startTimeout) {
      log('info', 'Bot already scheduled/running.');
      return;
    }
    if (!el.mnemonic.value || !el.unlockTime.value || !el.claimableId.value) {
      log('error', 'Keyphrase, Start Time (Local), and a selected Balance are required.');
      return;
    }

    el.start.disabled = true; el.stop.disabled = false;
    updateStatus('waiting', 'INITIALIZING...');

    // parse local start time (user provides local time string)
    const startTime = new Date(el.unlockTime.value).getTime();
    if (isNaN(startTime)) {
      log('error', 'Invalid Start Time format. Use YYYY-MM-DDTHH:MM:SS (local).');
      el.start.disabled = false; el.stop.disabled = true;
      return;
    }

    const earlyCall = parseInt(el.earlyCall.value, 10) || 0;
    const scanFreq = parseInt(el.scanFrequency.value, 10) || 500;
    const timeLimit = (parseInt(el.timeLimit.value, 10) || 20) * 1000;
    const retryInterval = parseInt(el.retryInterval.value, 10) || 0;
    const maxRetries = parseInt(el.maxRetryAttempts.value, 10) || 0;

    const scheduledStart = startTime - earlyCall;
    const waitTime = scheduledStart - Date.now();

    log('info', `Bot will START at ${new Date(scheduledStart).toLocaleString()} (local) — this only starts the retry loop. EarlyCall: ${earlyCall}ms.`);
    if (waitTime > 0) log('info', `Waiting ${Math.round(waitTime/1000)}s until start...`);

    // schedule the start (or start immediately if time already passed)
    startTimeout = setTimeout(() => {
      startTimeout = null;
      updateStatus('attacking', 'RUNNING');
      const endTime = Date.now() + timeLimit;
      isBusy = false;

      botInterval = setInterval(async () => {
        if (Date.now() > endTime) {
          log('error', 'Time limit reached. Bot stopped.');
          stopBot();
          return;
        }

        if (isBusy) {
          // previous tick still running, skip this tick to avoid overlap
          return;
        }
        isBusy = true;
        try {
          let success = await attemptTransaction();

          // if failed and retry is configured, perform sequential retries
          if (!success && retryInterval > 0 && maxRetries !== 0) { // maxRetries 0 means no retry
            const attemptsAllowed = (maxRetries > 0) ? maxRetries : Infinity; // treat negative as infinite, but default expects >=0
            for (let r = 0; r < attemptsAllowed && !success; r++) {
              log('info', `Retry #${r+1} in ${retryInterval}ms...`);
              await sleep(retryInterval);
              success = await attemptTransaction();
            }
          }

          if (success) {
            updateStatus('success', 'SUCCESS!');
            stopBot();
          }
        } finally {
          isBusy = false;
        }
      }, scanFreq);
    }, waitTime > 0 ? waitTime : 0);
  }

  function stopBot() {
    // clear scheduled start if exists
    if (startTimeout) { clearTimeout(startTimeout); startTimeout = null; log('info','Scheduled start cancelled.'); }
    if (botInterval) { clearInterval(botInterval); botInterval = null; }
    isBusy = false;
    el.start.disabled = false; el.stop.disabled = true;
    if (el.status.textContent !== 'STATUS: SUCCESS!') updateStatus('failed', 'STOPPED');
    log('info', 'Bot has been stopped.');
  }

  el.fetchBalances.addEventListener('click', fetchBalances);
  el.start.addEventListener('click', startBot);
  el.stop.addEventListener('click', stopBot);
</script>
</body>
</html>
